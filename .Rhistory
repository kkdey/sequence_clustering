)
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J))
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J)))
j=1
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J)))
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:J-j)))
index
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j)))
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=2
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=J-1
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=J-2
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.pm = rep(0, n)
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
j
x.pm
x.w.j
x.w.v.j
zdat.ash$PosteriorMean
ind.nnull
x.pm
x.pm[ind.nnull] = zdat.ash$PosteriorMean
!ind.nnull
x.pm
x.pm[ind.nnull] = zdat.ash$PosteriorMean
ind.nnull
x.pm
zdat.ash$PosteriorMean
x.pm
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
# mu.est.h1 = AvBasis(convert(x.w))
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
# mu.est.s8 = AvBasis(convert(x.w))
loglr.h1
loglr.s8
sum(loglr.h1)
sum(loglr.s8)
x.w
?iwd
?wd
mu.est.h1 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
loglr.h1
loglr.s8
plot(mu.est.h1,type='l')
lines(mu.est.s8,col=2)
mse(mu.est.h1,mu.cor)
mean((mu.est.h1-mu.cor)^2)
mean((mu.est.s8-mu.cor)^2)
sum(loglr.h1)
sum(loglr.s8)
library(ashr)
?ash
?ash.workhorse
setwd("D:/Grad School/projects/sequence_clustering/src")
source("cluster_seq_mix.R")
m = 15
n = 1024
peak1 = 201:400
peak2 = 501:700
peak3 = 801:900
signal = matrix(0.1, nr = m, nc = n)
signal[1:5, peak1] = 2
signal[1:5, peak2] = 2.5
signal[1:5, peak3] = 3
signal[6:10, ] = signal[1:5, ] * 2
signal[11:15, ] = signal[6:10, ] * 2
x = matrix(rpois(m*n, signal), nr = m, nc = n)
res.nonsmooth = cluster.mix(x, smooth = FALSE, K = 3, tol = 1e-4, maxit = 4000)
res.smooth = cluster.mix(x, smooth = TRUE, K = 3, tol = 1e-4, maxit = 4000)
save.image("results/simulations/simulation_identifiability.RData")
getwd()
setwd("D:/Grad School/projects/sequence_clustering")
save.image("results/simulations/simulation_identifiability.RData")
load("results/simulations/simulation_identifiability.RData")
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
res.nonsmooth$pi
res.smooth$pi
load("results/simulations/simulation_identifiability.RData")
pdf("simulation_identifiability.pdf", width = 8, height = 10)
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
dev.off()
pdf("results/simulations/simulation_identifiability.pdf", width = 8, height = 10)
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
dev.off()
pdf("results/simulations/simulation_identifiability.pdf", width = 8, height = 10)
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], ylim = c(0, 0.007), type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
dev.off()
pdf("results/simulations/simulation_identifiability.pdf", width = 8, height = 10)
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], ylim = c(0, 0.009), type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
dev.off()
pdf("results/simulations/simulation_identifiability.pdf", width = 8, height = 10)
par(mfrow = c(2, 1))
plot(res.nonsmooth$phi[1, ], type = 'l', main = "non-smoothed")
lines(res.nonsmooth$phi[2, ], col = 2)
lines(res.nonsmooth$phi[3, ], col = 3)
plot(res.smooth$phi[1, ], ylim = c(0, 0.008), type = 'l', main = "smoothed")
lines(res.smooth$phi[2, ], col = 2)
lines(res.smooth$phi[3, ], col = 3)
dev.off()

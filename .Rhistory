nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
# mu.est.h1 = AvBasis(convert(x.w))
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
# mu.est.s8 = AvBasis(convert(x.w))
loglr.h1
loglr.s8
sum(loglr.h1)
sum(loglr.s8)
x.w
?iwd
?wd
mu.est.h1 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
loglr.h1
loglr.s8
plot(mu.est.h1,type='l')
lines(mu.est.s8,col=2)
mse(mu.est.h1,mu.cor)
mean((mu.est.h1-mu.cor)^2)
mean((mu.est.s8-mu.cor)^2)
sum(loglr.h1)
sum(loglr.s8)
tt=matrix(sample(0:2,10,replace=TRUE),nr=5)
tt
is.integer(tt)
library(devtools)
install_github("zrxing/smash")
library(devtools)
install_github("zrxing/smash")
library(devtools)
install_github("zrxing/smash")
library(smash)
?smash
x=rnorm(256,1,1)
smash(x)
library(smash)
x=rnorm(256,1,1)
smash(x)
library(devtools)
install_github("zrxing/smash")
library(smash)
x=rnorm(256,1,1)
smash(x)
smash(x,model=NULL)
smash(x,model="gaus")
smash(x,model="pois")
smash(x,model="poiss")
x=rpois(256,1)
smash(x)
smash(x,model="gaus")
smash(x,model="poiss")
smash(x)
smash(x, v.est = tRUE)
smash(x, v.est = TRUE)
smash(x, model = "gaus", v.est = TRUE)
smash(x, model = "gaus", v.est = TRUE, joint = TRUE)
?smash
?smash.pois
?smash.poiss
?smash.gaus
library(smash)
?smash
??smash
library(devtools)
install_github("zrxing/smash")
library(smash)
?smash
?smashr
library(devtools)
install_github("zrxing/smashr")
install_github("zrxing/smashr", force = TRUE)
library(multiseq)
mu0 = rep(0.5, 1024)
mu1 = mu0
mu1[401:600] = 1
mu1 = mu1/sum(mu0)
plot(mu0)
lines(mu1,col=2)
plot(mu0,ylim=c(0,1))
lines(mu1,col=2)
sum(mu1)
sum(mu0)
mu0 = rep(0.5, 1024)
mu1 = mu0
mu1[401:600] = 1
mu1 = mu1/sum(mu1)*sum(mu0)
plot(mu0,ylim=c(0,1))
lines(mu1,col=2)
x0 = rpois(5*1024, mu0)
x1 = rpois(5*1024, mu1)
x0 = matrix(rpois(5*1024, mu0), nr = 5)
x1 = matrix(rpois(5*1024, mu1), nr = 5)
plot(x0, )
plot(x0[1,] )
plot(x1[1,] )
plot(x1[,1] )
plot(colMeans(x1))
x0 = matrix(rpois(5*1024, mu0), nr = 5, byrow = TRUE)
x1 = matrix(rpois(5*1024, mu1), nr = 5, byrow = TRUE)
plot(colMeans(x1))
g = rep(c(0, 1), each = 5)
g
x = rbind(x0, x1)
res = multiseq(x, g)
library(devtools)
install_github("zrxing/smashr")
library(smashr)
?smash
library(wavethresh)
edit(wd)
?wd
wd.D = function(data, filter.number = 10, family = "DaubLeAsymm", type = "wavelet", bc = "periodic", verbose = FALSE,
min.scale = 0, precond = TRUE) {
l = wd(data = data, filter.number = filter.number, family = family, type = type, bc = bc, verbose = verbose,
min.scale = min.scale, precond = precond)
return(l$D)
}
x = rnorm(256,0,1)
wd(x)
wd.D(x)
?convert
library(devtools)
install_github("zrxing/smashr")
library(smashr)
?smash
x=rnorm(256,0,1)
smash(x, family = "DaubLeAsymm", filter.number = 8)
?wd
smash(x, 'gaus', family = "DaubLeAsymm", filter.number = 8)
?smash
smash.gaus(x, family = "DaubLeAsymm", filter.number = 8)
smash.gaus(x)
wd(x)
?wd
library(smashr)
?wd
x=rnorm(256,0,1)
smash(x,family="DaubLeAsymm",filter.number=8)
smash(x)
res=smash(x,family="DaubLeAsymm",filter.number=8,post.var=TRUE)
res$var
res$mu.var
res
plot(res$mu.est.var)
plot(res$mu.est)
library(devtools)
install_github("zrxing/smashr")
library(smashr)
?smashr
mu.t = 0.01 + mu.s
# Simulate an example dataset
X.s = rpois(n, mu.t)
# Run smash
mu.est = smash(X.s, "poiss")
# Plot the true mean function as well as the estimated one
plot(mu.t, type = "l")
lines(mu.est, col = 2)
# Create the baseline mean function (The "spikes" function is used as an example here)
n = 2^9
t = 1:n/n
spike.f = function(x) (0.75 * exp(-500 * (x - 0.23)^2) + 1.5 * exp(-2000 * (x - 0.33)^2) + 3 * exp(-8000 * (x - 0.47)^2) +
2.25 * exp(-16000 * (x - 0.69)^2) + 0.5 * exp(-32000 * (x - 0.83)^2))
mu.s = spike.f(t)
# Poisson case
# Scale the signal to be non-zero and to have a low average intensity
mu.t = 0.01 + mu.s
# Simulate an example dataset
X.s = rpois(n, mu.t)
# Run smash
mu.est = smash(X.s, "poiss")
# Plot the true mean function as well as the estimated one
plot(mu.t, type = "l")
lines(mu.est, col = 2)
library(formatR)
?tidt
?tidy
?tidyR
?formatR
?format
??formatR
tidy_source()
library(multiseq)
get.counts
57603732-57607422
?sys
?system.call
region <- split_region(region)
locus.length <- region$end - region$start + 1
samples <- read.table(samplesheet, stringsAsFactors = F,
header = T)
4100-2880.7
setwd("D:/Grad School/projects/sequence_clustering")
library(multiseq)
?split_region
region=split_region("chr1:11740409-11756792")
print(region)
\?gsub
?gsub
gsub("[chr].*$","",region$chr)
gsub("^[chr].*$","",region$chr)
region$chr
gsub("[^0-9]","",region$chr)
load("data/gtex/reads_100_1_93297593_93307481.Robj")
ls
ls()
reads[[1]][[1]]
reads[[1]][[2]]
dim(reads[[1]][[2]])
rowSums(reads[[1]][[2]])
rowSums(reads[[2]][[2]])
rowSums(reads[[3]][[2]])
rowSums(reads[[4]][[2]])
rowSums(reads[[5]][[2]])
rowSums(reads[[6]][[2]])
rowSums(reads[[7]][[2]])
rowSums(reads[[8]][[2]])
load("data/gtex/reads_50_1_93297593_93307481.Robj")
rowSums(reads[[1]][[2]])
rowSums(reads[[2]][[2]])
load("data/gtex/reads_50_1_93297593_93307481.Robj")
for(i in 1:8){
print(rowSums(reads[[i]][[2]]))
}
reads[[7]][[4]]
reads[[7]][[2]][4,]
load("data/gtex/reads_50_1_93297593_93307481.Robj")
for(i in 1:8){
print(rowSums(reads[[i]][[2]]))
}

Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.pm = rep(0, n)
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
spins=2^(J-j)
index = (((J - 1) - j) * n + 1):((J - j) * n)
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = AvBasis(convert(x.w))
j
x.w.v.j
index
length(x.w.v)
x.w.v
tt=wd(1:16,filter.number=8,family="DaubLeAsymm")
tt$D
accessD(tt,0)
accessD(tt,3)
n/2+n/4+n/8+n/16+n/32+n/64+n/128+n/512+n/1024
n/2+n/4+n/8+n/16+n/32+n/64+n/128+n/256+n/512+n/1024
n/2+n/4+n/8+n/16+n/32+n/64+n/128+n/256+n/512+n/1024+1
n/2+n/4+n/8+n/16+n/32+n/64+n/128+n/256+n/512+1
513+256+128+64+32+16+8+4+2
513+256+128+64+32+16+8+4
513+256+128+64+32+16+8+4+2
n/(2^(1:2))
sum(n/(2^(1:(J-1))))
sum(n/(2^(1:J))
)
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J))
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J)))
j=1
(sum(n/(2^(1:(J-1))))+1):sum(n/(2^(1:J)))
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:J-j)))
index
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j)))
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=2
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=J-1
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
j=J-2
(sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.pm = rep(0, n)
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
j
x.pm
x.w.j
x.w.v.j
zdat.ash$PosteriorMean
ind.nnull
x.pm
x.pm[ind.nnull] = zdat.ash$PosteriorMean
!ind.nnull
x.pm
x.pm[ind.nnull] = zdat.ash$PosteriorMean
ind.nnull
x.pm
zdat.ash$PosteriorMean
x.pm
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
# mu.est.h1 = AvBasis(convert(x.w))
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
# mu.est.s8 = AvBasis(convert(x.w))
loglr.h1
loglr.s8
sum(loglr.h1)
sum(loglr.s8)
x.w
?iwd
?wd
mu.est.h1 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n * J) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
filter.number = 1
family = "DaubExPhase"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.h1=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.h1[j+1]=loglr.temp/spins
}
mu.est.h1 = wr(x.w)
#################
filter.number = 8
family = "DaubLeAsymm"
n = length(x)
J = log2(n)
if (!isTRUE(all.equal(J, trunc(J)))) {
stop("Error: number of columns of x must be power of 2")
}
ashparam = smash:::setAshParam.gaus(ashparam)
if (v.est == TRUE) {
weight = 1
} else {
weight = 0.5
}
# if(post.var==TRUE&basis[[1]]!='haar'){stop('Error: posterior variances returned only with Haar basis')}
if (post.var == TRUE & v.est == TRUE & jash == TRUE) {
stop("Error: Posterior variances for variance estimate not returned for method JASH")
}
if (joint == TRUE) {
v.est = TRUE
}
tsum = sum(x)
Wl = NULL
x.w.d = wd(x, filter.number = filter.number, family = family)
Wl = wt.mat(n, filter.number = filter.number, family = family)
wc=x.w.d
data.var=sigma.cor.3.v2^2
wmean = matrix(0, J, n)
wvar = matrix(0, J, n)
loglr.s8=0
x.w = wc
x.w.v = apply((rep(1, n - 1) %o% data.var) * Wl$W2, 1, sum)  #diagonal of W*V*W'
x.w.v.s = rep(0, n * J)
for (j in 0:(J - 1)) {
x.pm = rep(0, 2^j)
spins=2^(J-j)
if(j!=(J-1)){
index = (sum(n/(2^(1:(J-j-1))))+1):sum(n/(2^(1:(J-j))))
}else{
index = 1:sum(n/2)
}
x.w.j = accessD(x.w, j)
x.w.v.j = x.w.v[index]
ind.nnull = (x.w.v.j != 0)
zdat.ash = smash:::shrink.wc(x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]), prior = ashparam$prior, pointmass = ashparam$pointmass,
nullcheck = ashparam$nullcheck, VB = ashparam$VB, mixsd = ashparam$mixsd, mixcompdist = ashparam$mixcompdist, gridmult = ashparam$gridmult, jash = FALSE,
df = NULL, SGD = FALSE)
x.pm[ind.nnull] = zdat.ash$PosteriorMean
x.pm[!ind.nnull] = 0
x.w = putD(x.w, j, x.pm)
zdat.ash$model = "EE"
loglr.temp = ashr:::calc_loglik(zdat.ash,x.w.j[ind.nnull], sqrt(x.w.v.j[ind.nnull]),NULL) -
sum(dnorm(x.w.j[ind.nnull], 0, sqrt(x.w.v.j[ind.nnull]), log = TRUE))
loglr.s8[j+1]=loglr.temp/spins
}
mu.est.s8 = wr(x.w)
loglr.h1
loglr.s8
plot(mu.est.h1,type='l')
lines(mu.est.s8,col=2)
mse(mu.est.h1,mu.cor)
mean((mu.est.h1-mu.cor)^2)
mean((mu.est.s8-mu.cor)^2)
sum(loglr.h1)
sum(loglr.s8)
setwd("D:/Grad School/projects/sequence_clustering/results/analysis_oas1")
setwd("D:/Grad School/projects/sequence_clustering")
path = "D:/Grad School/projects/sequence_clustering"
setwd(path)
load(paste0(path, "/data/oas1/OAS1.Robj"))
Robj$g[5]
plot(ashsmooth.pois(as.matrix(Robj$M$M)[5, ]), type='l')
library(smash)
plot(ashsmooth.pois(as.matrix(Robj$M$M)[5, ]), type='l')
plot(ashsmooth.pois(as.matrix(Robj$M$M)[5, 2049:4096]), type='l')
plot(ashsmooth.pois(as.matrix(Robj$M$M)[5, 2049:4096]), ylim = c(0, 15), type='l')
Robj$M
Robj$M[5,]
Robj$M$M[5,]
M = Robj$M$M
M = as.matrix(Robj$M$M)
M = M[-5,]
dim(M)
g=Robj$g[-5]
read.depth
Robj$read.depth
read.depth=Robj$read.depth[-5]
save(M,g,read.depth, file="data/oas1/OAS1_mod.Robj")
load("data/oas1/OAS1_mod.Robj")
source("src/cluster_seq_mix.R")
data = M
res = cluster.mix(data[, 2049:4096], smooth = TRUE, K = 4, tol = 1e-4, maxit = 4000)
warnings()
save.image("D:/Grad School/projects/sequence_clustering/results/analysis_oas1/res_smooth_3_mod.RData")
save.image("D:/Grad School/projects/sequence_clustering/results/analysis_oas1/res_smooth_4_mod.RData")
